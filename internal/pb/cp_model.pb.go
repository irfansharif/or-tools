// Copyright 2010-2018 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Proto describing a general Constraint Programming (CP) problem.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.1
// 	protoc        v3.14.0
// source: cp_model.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The status returned by a solver trying to solve a CpModelProto.
type CpSolverStatus int32

const (
	// The status of the model is still unknown. A search limit has been reached
	// before any of the statuses below could be determined.
	CpSolverStatus_UNKNOWN CpSolverStatus = 0
	// The given CpModelProto didn't pass the validation step. You can get a
	// detailed error by calling ValidateCpModel(model_proto).
	CpSolverStatus_MODEL_INVALID CpSolverStatus = 1
	// A feasible solution as been found. But the search was stopped before we
	// could prove optimality or before we enumerated all solutions of a
	// feasibility problem (if asked).
	CpSolverStatus_FEASIBLE CpSolverStatus = 2
	// The problem has been proven infeasible.
	CpSolverStatus_INFEASIBLE CpSolverStatus = 3
	// An optimal feasible solution has been found.
	//
	// More generally, this status represent a success. So we also return OPTIMAL
	// if we find a solution for a pure feasiblity problem or if a gap limit has
	// been specified and we return a solution within this limit. In the case
	// where we need to return all the feasible solution, this status will only be
	// returned if we enumerated all of them; If we stopped before, we will return
	// FEASIBLE.
	CpSolverStatus_OPTIMAL CpSolverStatus = 4
)

// Enum value maps for CpSolverStatus.
var (
	CpSolverStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "MODEL_INVALID",
		2: "FEASIBLE",
		3: "INFEASIBLE",
		4: "OPTIMAL",
	}
	CpSolverStatus_value = map[string]int32{
		"UNKNOWN":       0,
		"MODEL_INVALID": 1,
		"FEASIBLE":      2,
		"INFEASIBLE":    3,
		"OPTIMAL":       4,
	}
)

func (x CpSolverStatus) Enum() *CpSolverStatus {
	p := new(CpSolverStatus)
	*p = x
	return p
}

func (x CpSolverStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CpSolverStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_cp_model_proto_enumTypes[0].Descriptor()
}

func (CpSolverStatus) Type() protoreflect.EnumType {
	return &file_cp_model_proto_enumTypes[0]
}

func (x CpSolverStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CpSolverStatus.Descriptor instead.
func (CpSolverStatus) EnumDescriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{0}
}

// The order in which the variables above should be considered. Note that only
// variables that are not already fixed are considered.
//
// TODO(user): extend as needed.
type DecisionStrategyProto_VariableSelectionStrategy int32

const (
	DecisionStrategyProto_CHOOSE_FIRST           DecisionStrategyProto_VariableSelectionStrategy = 0
	DecisionStrategyProto_CHOOSE_LOWEST_MIN      DecisionStrategyProto_VariableSelectionStrategy = 1
	DecisionStrategyProto_CHOOSE_HIGHEST_MAX     DecisionStrategyProto_VariableSelectionStrategy = 2
	DecisionStrategyProto_CHOOSE_MIN_DOMAIN_SIZE DecisionStrategyProto_VariableSelectionStrategy = 3
	DecisionStrategyProto_CHOOSE_MAX_DOMAIN_SIZE DecisionStrategyProto_VariableSelectionStrategy = 4
)

// Enum value maps for DecisionStrategyProto_VariableSelectionStrategy.
var (
	DecisionStrategyProto_VariableSelectionStrategy_name = map[int32]string{
		0: "CHOOSE_FIRST",
		1: "CHOOSE_LOWEST_MIN",
		2: "CHOOSE_HIGHEST_MAX",
		3: "CHOOSE_MIN_DOMAIN_SIZE",
		4: "CHOOSE_MAX_DOMAIN_SIZE",
	}
	DecisionStrategyProto_VariableSelectionStrategy_value = map[string]int32{
		"CHOOSE_FIRST":           0,
		"CHOOSE_LOWEST_MIN":      1,
		"CHOOSE_HIGHEST_MAX":     2,
		"CHOOSE_MIN_DOMAIN_SIZE": 3,
		"CHOOSE_MAX_DOMAIN_SIZE": 4,
	}
)

func (x DecisionStrategyProto_VariableSelectionStrategy) Enum() *DecisionStrategyProto_VariableSelectionStrategy {
	p := new(DecisionStrategyProto_VariableSelectionStrategy)
	*p = x
	return p
}

func (x DecisionStrategyProto_VariableSelectionStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DecisionStrategyProto_VariableSelectionStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_cp_model_proto_enumTypes[1].Descriptor()
}

func (DecisionStrategyProto_VariableSelectionStrategy) Type() protoreflect.EnumType {
	return &file_cp_model_proto_enumTypes[1]
}

func (x DecisionStrategyProto_VariableSelectionStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DecisionStrategyProto_VariableSelectionStrategy.Descriptor instead.
func (DecisionStrategyProto_VariableSelectionStrategy) EnumDescriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{21, 0}
}

// Once a variable has been chosen, this enum describe what decision is taken
// on its domain.
//
// TODO(user): extend as needed.
type DecisionStrategyProto_DomainReductionStrategy int32

const (
	DecisionStrategyProto_SELECT_MIN_VALUE    DecisionStrategyProto_DomainReductionStrategy = 0
	DecisionStrategyProto_SELECT_MAX_VALUE    DecisionStrategyProto_DomainReductionStrategy = 1
	DecisionStrategyProto_SELECT_LOWER_HALF   DecisionStrategyProto_DomainReductionStrategy = 2
	DecisionStrategyProto_SELECT_UPPER_HALF   DecisionStrategyProto_DomainReductionStrategy = 3
	DecisionStrategyProto_SELECT_MEDIAN_VALUE DecisionStrategyProto_DomainReductionStrategy = 4
)

// Enum value maps for DecisionStrategyProto_DomainReductionStrategy.
var (
	DecisionStrategyProto_DomainReductionStrategy_name = map[int32]string{
		0: "SELECT_MIN_VALUE",
		1: "SELECT_MAX_VALUE",
		2: "SELECT_LOWER_HALF",
		3: "SELECT_UPPER_HALF",
		4: "SELECT_MEDIAN_VALUE",
	}
	DecisionStrategyProto_DomainReductionStrategy_value = map[string]int32{
		"SELECT_MIN_VALUE":    0,
		"SELECT_MAX_VALUE":    1,
		"SELECT_LOWER_HALF":   2,
		"SELECT_UPPER_HALF":   3,
		"SELECT_MEDIAN_VALUE": 4,
	}
)

func (x DecisionStrategyProto_DomainReductionStrategy) Enum() *DecisionStrategyProto_DomainReductionStrategy {
	p := new(DecisionStrategyProto_DomainReductionStrategy)
	*p = x
	return p
}

func (x DecisionStrategyProto_DomainReductionStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DecisionStrategyProto_DomainReductionStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_cp_model_proto_enumTypes[2].Descriptor()
}

func (DecisionStrategyProto_DomainReductionStrategy) Type() protoreflect.EnumType {
	return &file_cp_model_proto_enumTypes[2]
}

func (x DecisionStrategyProto_DomainReductionStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DecisionStrategyProto_DomainReductionStrategy.Descriptor instead.
func (DecisionStrategyProto_DomainReductionStrategy) EnumDescriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{21, 1}
}

// An integer variable.
//
// It will be referred to by an int32 corresponding to its index in a
// CpModelProto variables field.
//
// Depending on the context, a reference to a variable whose domain is in [0, 1]
// can also be seen as a Boolean that will be true if the variable value is 1
// and false if it is 0. When used in this context, the field name will always
// contain the word "literal".
//
// Negative reference (advanced usage): to simplify the creation of a model and
// for efficiency reasons, all the "literal" or "variable" fields can also
// contain a negative index. A negative index i will refer to the negation of
// the integer variable at index -i -1 or to NOT the literal at the same index.
//
// Ex: A variable index 4 will refer to the integer variable model.variables(4)
// and an index of -5 will refer to the negation of the same variable. A literal
// index 4 will refer to the logical fact that model.variable(4) == 1 and a
// literal index of -5 will refer to the logical fact model.variable(4) == 0.
type IntegerVariableProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The variable domain given as a sorted list of n disjoint intervals
	// [min, max] and encoded as [min_0, max_0,  ..., min_{n-1}, max_{n-1}].
	//
	// The most common example being just [min, max].
	// If min == max, then this is a constant variable.
	//
	// We have:
	//  - domain_size() is always even.
	//  - min == domain.front();
	//  - max == domain.back();
	//  - for all i < n   :      min_i <= max_i
	//  - for all i < n-1 :  max_i + 1 < min_{i+1}.
	//
	// Note that we check at validation that a variable domain is small enough so
	// that we don't run into integer overflow in our algorithms. Because of that,
	// you cannot just have "unbounded" variable like [0, kint64max] and should
	// try to specify tighter domains.
	Domain []int64 `protobuf:"varint,2,rep,packed,name=domain,proto3" json:"domain,omitempty"`
}

func (x *IntegerVariableProto) Reset() {
	*x = IntegerVariableProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IntegerVariableProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntegerVariableProto) ProtoMessage() {}

func (x *IntegerVariableProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntegerVariableProto.ProtoReflect.Descriptor instead.
func (*IntegerVariableProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{0}
}

func (x *IntegerVariableProto) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IntegerVariableProto) GetDomain() []int64 {
	if x != nil {
		return x.Domain
	}
	return nil
}

// Argument of the constraints of the form OP(literals).
type BoolArgumentProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Literals []int32 `protobuf:"varint,1,rep,packed,name=literals,proto3" json:"literals,omitempty"`
}

func (x *BoolArgumentProto) Reset() {
	*x = BoolArgumentProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BoolArgumentProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoolArgumentProto) ProtoMessage() {}

func (x *BoolArgumentProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoolArgumentProto.ProtoReflect.Descriptor instead.
func (*BoolArgumentProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{1}
}

func (x *BoolArgumentProto) GetLiterals() []int32 {
	if x != nil {
		return x.Literals
	}
	return nil
}

// Argument of the constraints of the form target_var = OP(vars).
type IntegerArgumentProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Target int32   `protobuf:"varint,1,opt,name=target,proto3" json:"target,omitempty"`
	Vars   []int32 `protobuf:"varint,2,rep,packed,name=vars,proto3" json:"vars,omitempty"`
}

func (x *IntegerArgumentProto) Reset() {
	*x = IntegerArgumentProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IntegerArgumentProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntegerArgumentProto) ProtoMessage() {}

func (x *IntegerArgumentProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntegerArgumentProto.ProtoReflect.Descriptor instead.
func (*IntegerArgumentProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{2}
}

func (x *IntegerArgumentProto) GetTarget() int32 {
	if x != nil {
		return x.Target
	}
	return 0
}

func (x *IntegerArgumentProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

type LinearExpressionProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []int64 `protobuf:"varint,2,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	Offset int64   `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *LinearExpressionProto) Reset() {
	*x = LinearExpressionProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinearExpressionProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinearExpressionProto) ProtoMessage() {}

func (x *LinearExpressionProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinearExpressionProto.ProtoReflect.Descriptor instead.
func (*LinearExpressionProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{3}
}

func (x *LinearExpressionProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *LinearExpressionProto) GetCoeffs() []int64 {
	if x != nil {
		return x.Coeffs
	}
	return nil
}

func (x *LinearExpressionProto) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type LinearArgumentProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Target *LinearExpressionProto   `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	Exprs  []*LinearExpressionProto `protobuf:"bytes,2,rep,name=exprs,proto3" json:"exprs,omitempty"`
}

func (x *LinearArgumentProto) Reset() {
	*x = LinearArgumentProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinearArgumentProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinearArgumentProto) ProtoMessage() {}

func (x *LinearArgumentProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinearArgumentProto.ProtoReflect.Descriptor instead.
func (*LinearArgumentProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{4}
}

func (x *LinearArgumentProto) GetTarget() *LinearExpressionProto {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *LinearArgumentProto) GetExprs() []*LinearExpressionProto {
	if x != nil {
		return x.Exprs
	}
	return nil
}

// All variables must take different values.
type AllDifferentConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
}

func (x *AllDifferentConstraintProto) Reset() {
	*x = AllDifferentConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AllDifferentConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllDifferentConstraintProto) ProtoMessage() {}

func (x *AllDifferentConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllDifferentConstraintProto.ProtoReflect.Descriptor instead.
func (*AllDifferentConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{5}
}

func (x *AllDifferentConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

// The linear sum vars[i] * coeffs[i] must fall in the given domain. The domain
// has the same format as the one in IntegerVariableProto.
//
// Note that the validation code currently checks using the domain of the
// involved variables that the sum can always be computed without integer
// overflow and throws an error otherwise.
type LinearConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []int64 `protobuf:"varint,2,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"` // Same size as vars.
	Domain []int64 `protobuf:"varint,3,rep,packed,name=domain,proto3" json:"domain,omitempty"`
}

func (x *LinearConstraintProto) Reset() {
	*x = LinearConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinearConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinearConstraintProto) ProtoMessage() {}

func (x *LinearConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinearConstraintProto.ProtoReflect.Descriptor instead.
func (*LinearConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{6}
}

func (x *LinearConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *LinearConstraintProto) GetCoeffs() []int64 {
	if x != nil {
		return x.Coeffs
	}
	return nil
}

func (x *LinearConstraintProto) GetDomain() []int64 {
	if x != nil {
		return x.Domain
	}
	return nil
}

// The constraint target = vars[index].
// This enforces that index takes one of the value in [0, vars_size()).
type ElementConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Index  int32   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Target int32   `protobuf:"varint,2,opt,name=target,proto3" json:"target,omitempty"`
	Vars   []int32 `protobuf:"varint,3,rep,packed,name=vars,proto3" json:"vars,omitempty"`
}

func (x *ElementConstraintProto) Reset() {
	*x = ElementConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ElementConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ElementConstraintProto) ProtoMessage() {}

func (x *ElementConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ElementConstraintProto.ProtoReflect.Descriptor instead.
func (*ElementConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{7}
}

func (x *ElementConstraintProto) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *ElementConstraintProto) GetTarget() int32 {
	if x != nil {
		return x.Target
	}
	return 0
}

func (x *ElementConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

// This "special" constraint not only enforces (start + size == end) but can
// also be referred by other constraints using this "interval" concept.
type IntervalConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Size  int32 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *IntervalConstraintProto) Reset() {
	*x = IntervalConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IntervalConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntervalConstraintProto) ProtoMessage() {}

func (x *IntervalConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntervalConstraintProto.ProtoReflect.Descriptor instead.
func (*IntervalConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{8}
}

func (x *IntervalConstraintProto) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *IntervalConstraintProto) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

func (x *IntervalConstraintProto) GetSize() int32 {
	if x != nil {
		return x.Size
	}
	return 0
}

// All the intervals (index of IntervalConstraintProto) must be disjoint. More
// formally, there must exist a sequence so that for each consecutive intervals,
// we have end_i <= start_{i+1}. In particular, intervals of size zero do matter
// for this constraint. This is also known as a disjunctive constraint in
// scheduling.
type NoOverlapConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Intervals []int32 `protobuf:"varint,1,rep,packed,name=intervals,proto3" json:"intervals,omitempty"`
}

func (x *NoOverlapConstraintProto) Reset() {
	*x = NoOverlapConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NoOverlapConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NoOverlapConstraintProto) ProtoMessage() {}

func (x *NoOverlapConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NoOverlapConstraintProto.ProtoReflect.Descriptor instead.
func (*NoOverlapConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{9}
}

func (x *NoOverlapConstraintProto) GetIntervals() []int32 {
	if x != nil {
		return x.Intervals
	}
	return nil
}

// The boxes defined by [start_x, end_x) * [start_y, end_y) cannot overlap.
type NoOverlap2DConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	XIntervals                  []int32 `protobuf:"varint,1,rep,packed,name=x_intervals,json=xIntervals,proto3" json:"x_intervals,omitempty"`
	YIntervals                  []int32 `protobuf:"varint,2,rep,packed,name=y_intervals,json=yIntervals,proto3" json:"y_intervals,omitempty"` // Same size as x_intervals.
	BoxesWithNullAreaCanOverlap bool    `protobuf:"varint,3,opt,name=boxes_with_null_area_can_overlap,json=boxesWithNullAreaCanOverlap,proto3" json:"boxes_with_null_area_can_overlap,omitempty"`
}

func (x *NoOverlap2DConstraintProto) Reset() {
	*x = NoOverlap2DConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NoOverlap2DConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NoOverlap2DConstraintProto) ProtoMessage() {}

func (x *NoOverlap2DConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NoOverlap2DConstraintProto.ProtoReflect.Descriptor instead.
func (*NoOverlap2DConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{10}
}

func (x *NoOverlap2DConstraintProto) GetXIntervals() []int32 {
	if x != nil {
		return x.XIntervals
	}
	return nil
}

func (x *NoOverlap2DConstraintProto) GetYIntervals() []int32 {
	if x != nil {
		return x.YIntervals
	}
	return nil
}

func (x *NoOverlap2DConstraintProto) GetBoxesWithNullAreaCanOverlap() bool {
	if x != nil {
		return x.BoxesWithNullAreaCanOverlap
	}
	return false
}

// The sum of the demands of the intervals at each interval point cannot exceed
// a capacity. Note that intervals are interpreted as [start, end) and as
// such intervals like [2,3) and [3,4) do not overlap for the point of view of
// this constraint. Moreover, intervals of size zero are ignored.
type CumulativeConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Capacity  int32   `protobuf:"varint,1,opt,name=capacity,proto3" json:"capacity,omitempty"`
	Intervals []int32 `protobuf:"varint,2,rep,packed,name=intervals,proto3" json:"intervals,omitempty"`
	Demands   []int32 `protobuf:"varint,3,rep,packed,name=demands,proto3" json:"demands,omitempty"` // Same size as intervals.
}

func (x *CumulativeConstraintProto) Reset() {
	*x = CumulativeConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CumulativeConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CumulativeConstraintProto) ProtoMessage() {}

func (x *CumulativeConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CumulativeConstraintProto.ProtoReflect.Descriptor instead.
func (*CumulativeConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{11}
}

func (x *CumulativeConstraintProto) GetCapacity() int32 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *CumulativeConstraintProto) GetIntervals() []int32 {
	if x != nil {
		return x.Intervals
	}
	return nil
}

func (x *CumulativeConstraintProto) GetDemands() []int32 {
	if x != nil {
		return x.Demands
	}
	return nil
}

// Maintain a reservoir level within bounds. The water level starts at 0, and at
// any time >= 0, it must be within min_level, and max_level. Furthermore, this
// constraints expect all times variables to be >= 0.
// If the variable actives[i] is true, and if the variable times[i] is assigned
// a value t, then the current level changes by demands[i] (which is constant)
// at the time t.
//
// Note that level min can be > 0, or level max can be < 0. It just forces
// some demands to be executed at time 0 to make sure that we are within those
// bounds with the executed demands. Therefore, at any time t >= 0:
//      sum(demands[i] * actives[i] if times[i] <= t) in [min_level, max_level]
// The array of boolean variables 'actives', if defined, indicates which actions
// are actually performed. If this array is not defined, then it is assumed that
// all actions will be performed.
type ReservoirConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MinLevel int64   `protobuf:"varint,1,opt,name=min_level,json=minLevel,proto3" json:"min_level,omitempty"`
	MaxLevel int64   `protobuf:"varint,2,opt,name=max_level,json=maxLevel,proto3" json:"max_level,omitempty"`
	Times    []int32 `protobuf:"varint,3,rep,packed,name=times,proto3" json:"times,omitempty"`     // variables.
	Demands  []int64 `protobuf:"varint,4,rep,packed,name=demands,proto3" json:"demands,omitempty"` // constants, can be negative.
	Actives  []int32 `protobuf:"varint,5,rep,packed,name=actives,proto3" json:"actives,omitempty"` // literals.
}

func (x *ReservoirConstraintProto) Reset() {
	*x = ReservoirConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReservoirConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReservoirConstraintProto) ProtoMessage() {}

func (x *ReservoirConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReservoirConstraintProto.ProtoReflect.Descriptor instead.
func (*ReservoirConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{12}
}

func (x *ReservoirConstraintProto) GetMinLevel() int64 {
	if x != nil {
		return x.MinLevel
	}
	return 0
}

func (x *ReservoirConstraintProto) GetMaxLevel() int64 {
	if x != nil {
		return x.MaxLevel
	}
	return 0
}

func (x *ReservoirConstraintProto) GetTimes() []int32 {
	if x != nil {
		return x.Times
	}
	return nil
}

func (x *ReservoirConstraintProto) GetDemands() []int64 {
	if x != nil {
		return x.Demands
	}
	return nil
}

func (x *ReservoirConstraintProto) GetActives() []int32 {
	if x != nil {
		return x.Actives
	}
	return nil
}

// The circuit constraint is defined on a graph where the arc presence are
// controlled by literals. Each arc is given by an index in the
// tails/heads/literals lists that must have the same size.
//
// For now, we ignore node indices with no incident arc. All the other nodes
// must have exactly one incoming and one outgoing selected arc (i.e. literal at
// true). All the selected arcs that are not self-loops must form a single
// circuit. Note that multi-arcs are allowed, but only one of them will be true
// at the same time. Multi-self loop are disallowed though.
type CircuitConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Tails    []int32 `protobuf:"varint,3,rep,packed,name=tails,proto3" json:"tails,omitempty"`
	Heads    []int32 `protobuf:"varint,4,rep,packed,name=heads,proto3" json:"heads,omitempty"`
	Literals []int32 `protobuf:"varint,5,rep,packed,name=literals,proto3" json:"literals,omitempty"`
}

func (x *CircuitConstraintProto) Reset() {
	*x = CircuitConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CircuitConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircuitConstraintProto) ProtoMessage() {}

func (x *CircuitConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CircuitConstraintProto.ProtoReflect.Descriptor instead.
func (*CircuitConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{13}
}

func (x *CircuitConstraintProto) GetTails() []int32 {
	if x != nil {
		return x.Tails
	}
	return nil
}

func (x *CircuitConstraintProto) GetHeads() []int32 {
	if x != nil {
		return x.Heads
	}
	return nil
}

func (x *CircuitConstraintProto) GetLiterals() []int32 {
	if x != nil {
		return x.Literals
	}
	return nil
}

// The "VRP" (Vehicle Routing Problem) constraint.
//
// The direct graph where arc #i (from tails[i] to head[i]) is present iff
// literals[i] is true must satisfy this set of properties:
// - #incoming arcs == 1 except for node 0.
// - #outgoing arcs == 1 except for node 0.
// - for node zero, #incoming arcs == #outgoing arcs.
// - There are no duplicate arcs.
// - Self-arcs are allowed except for node 0.
// - There is no cycle in this graph, except through node 0.
//
// TODO(user): It is probably possible to generalize this constraint to a
// no-cycle in a general graph, or a no-cycle with sum incoming <= 1 and sum
// outgoing <= 1 (more efficient implementation). On the other hand, having this
// specific constraint allow us to add specific "cuts" to a VRP problem.
type RoutesConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Tails    []int32 `protobuf:"varint,1,rep,packed,name=tails,proto3" json:"tails,omitempty"`
	Heads    []int32 `protobuf:"varint,2,rep,packed,name=heads,proto3" json:"heads,omitempty"`
	Literals []int32 `protobuf:"varint,3,rep,packed,name=literals,proto3" json:"literals,omitempty"`
	// Experimental. The demands for each node, and the maximum capacity for each
	// route. Note that this is currently only used for the LP relaxation and one
	// need to add the corresponding constraint to enforce this outside of the LP.
	Demands  []int32 `protobuf:"varint,4,rep,packed,name=demands,proto3" json:"demands,omitempty"`
	Capacity int64   `protobuf:"varint,5,opt,name=capacity,proto3" json:"capacity,omitempty"`
}

func (x *RoutesConstraintProto) Reset() {
	*x = RoutesConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RoutesConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutesConstraintProto) ProtoMessage() {}

func (x *RoutesConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutesConstraintProto.ProtoReflect.Descriptor instead.
func (*RoutesConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{14}
}

func (x *RoutesConstraintProto) GetTails() []int32 {
	if x != nil {
		return x.Tails
	}
	return nil
}

func (x *RoutesConstraintProto) GetHeads() []int32 {
	if x != nil {
		return x.Heads
	}
	return nil
}

func (x *RoutesConstraintProto) GetLiterals() []int32 {
	if x != nil {
		return x.Literals
	}
	return nil
}

func (x *RoutesConstraintProto) GetDemands() []int32 {
	if x != nil {
		return x.Demands
	}
	return nil
}

func (x *RoutesConstraintProto) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

// Another routing constraint. This one forces the nexts variables to form a
// permutation, and cycles of this permutation of length more than 1 (nonloops)
// to contain exactly one of the distinguished nodes.
type CircuitCoveringConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nexts              []int32 `protobuf:"varint,1,rep,packed,name=nexts,proto3" json:"nexts,omitempty"`
	DistinguishedNodes []int64 `protobuf:"varint,2,rep,packed,name=distinguished_nodes,json=distinguishedNodes,proto3" json:"distinguished_nodes,omitempty"`
}

func (x *CircuitCoveringConstraintProto) Reset() {
	*x = CircuitCoveringConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CircuitCoveringConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircuitCoveringConstraintProto) ProtoMessage() {}

func (x *CircuitCoveringConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CircuitCoveringConstraintProto.ProtoReflect.Descriptor instead.
func (*CircuitCoveringConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{15}
}

func (x *CircuitCoveringConstraintProto) GetNexts() []int32 {
	if x != nil {
		return x.Nexts
	}
	return nil
}

func (x *CircuitCoveringConstraintProto) GetDistinguishedNodes() []int64 {
	if x != nil {
		return x.DistinguishedNodes
	}
	return nil
}

// The values of the n-tuple formed by the given variables can only be one of
// the listed n-tuples in values. The n-tuples are encoded in a flattened way:
//     [tuple0_v0, tuple0_v1, ..., tuple0_v{n-1}, tuple1_v0, ...].
type TableConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Values []int64 `protobuf:"varint,2,rep,packed,name=values,proto3" json:"values,omitempty"`
	// If true, the meaning is "negated", that is we forbid any of the given
	// tuple from a feasible assignment.
	Negated bool `protobuf:"varint,3,opt,name=negated,proto3" json:"negated,omitempty"`
}

func (x *TableConstraintProto) Reset() {
	*x = TableConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TableConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableConstraintProto) ProtoMessage() {}

func (x *TableConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableConstraintProto.ProtoReflect.Descriptor instead.
func (*TableConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{16}
}

func (x *TableConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *TableConstraintProto) GetValues() []int64 {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *TableConstraintProto) GetNegated() bool {
	if x != nil {
		return x.Negated
	}
	return false
}

// The two arrays of variable each represent a function, the second is the
// inverse of the first: f_direct[i] == j <=> f_inverse[j] == i.
type InverseConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FDirect  []int32 `protobuf:"varint,1,rep,packed,name=f_direct,json=fDirect,proto3" json:"f_direct,omitempty"`
	FInverse []int32 `protobuf:"varint,2,rep,packed,name=f_inverse,json=fInverse,proto3" json:"f_inverse,omitempty"`
}

func (x *InverseConstraintProto) Reset() {
	*x = InverseConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InverseConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InverseConstraintProto) ProtoMessage() {}

func (x *InverseConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InverseConstraintProto.ProtoReflect.Descriptor instead.
func (*InverseConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{17}
}

func (x *InverseConstraintProto) GetFDirect() []int32 {
	if x != nil {
		return x.FDirect
	}
	return nil
}

func (x *InverseConstraintProto) GetFInverse() []int32 {
	if x != nil {
		return x.FInverse
	}
	return nil
}

// This constraint forces a sequence of variables to be accepted by an
// automaton.
type AutomatonConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A state is identified by a non-negative number. It is preferable to keep
	// all the states dense in says [0, num_states). The automaton starts at
	// starting_state and must finish in any of the final states.
	StartingState int64   `protobuf:"varint,2,opt,name=starting_state,json=startingState,proto3" json:"starting_state,omitempty"`
	FinalStates   []int64 `protobuf:"varint,3,rep,packed,name=final_states,json=finalStates,proto3" json:"final_states,omitempty"`
	// List of transitions (all 3 vectors have the same size). Both tail and head
	// are states, label is any variable value. No two outgoing transitions from
	// the same state can have the same label.
	TransitionTail  []int64 `protobuf:"varint,4,rep,packed,name=transition_tail,json=transitionTail,proto3" json:"transition_tail,omitempty"`
	TransitionHead  []int64 `protobuf:"varint,5,rep,packed,name=transition_head,json=transitionHead,proto3" json:"transition_head,omitempty"`
	TransitionLabel []int64 `protobuf:"varint,6,rep,packed,name=transition_label,json=transitionLabel,proto3" json:"transition_label,omitempty"`
	// The sequence of variables. The automaton is ran for vars_size() "steps" and
	// the value of vars[i] corresponds to the transition label at step i.
	Vars []int32 `protobuf:"varint,7,rep,packed,name=vars,proto3" json:"vars,omitempty"`
}

func (x *AutomatonConstraintProto) Reset() {
	*x = AutomatonConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutomatonConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomatonConstraintProto) ProtoMessage() {}

func (x *AutomatonConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomatonConstraintProto.ProtoReflect.Descriptor instead.
func (*AutomatonConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{18}
}

func (x *AutomatonConstraintProto) GetStartingState() int64 {
	if x != nil {
		return x.StartingState
	}
	return 0
}

func (x *AutomatonConstraintProto) GetFinalStates() []int64 {
	if x != nil {
		return x.FinalStates
	}
	return nil
}

func (x *AutomatonConstraintProto) GetTransitionTail() []int64 {
	if x != nil {
		return x.TransitionTail
	}
	return nil
}

func (x *AutomatonConstraintProto) GetTransitionHead() []int64 {
	if x != nil {
		return x.TransitionHead
	}
	return nil
}

func (x *AutomatonConstraintProto) GetTransitionLabel() []int64 {
	if x != nil {
		return x.TransitionLabel
	}
	return nil
}

func (x *AutomatonConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

// Next id: 29
type ConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The constraint will be enforced iff all literals listed here are true. If
	// this is empty, then the constraint will always be enforced. An enforced
	// constraint must be satisfied, and an un-enforced one will simply be
	// ignored.
	//
	// This is also called half-reification. To have an equivalence between a
	// literal and a constraint (full reification), one must add both a constraint
	// (controlled by a literal l) and its negation (controlled by the negation of
	// l).
	//
	// Important: as of September 2018, only a few constraint support enforcement:
	// - bool_or, bool_and, linear: fully supported.
	// - interval: only support a single enforcement literal.
	// - other: no support (but can be added on a per-demand basis).
	EnforcementLiteral []int32 `protobuf:"varint,2,rep,packed,name=enforcement_literal,json=enforcementLiteral,proto3" json:"enforcement_literal,omitempty"`
	// The actual constraint with its arguments.
	//
	// Types that are assignable to Constraint:
	//	*ConstraintProto_BoolOr
	//	*ConstraintProto_BoolAnd
	//	*ConstraintProto_AtMostOne
	//	*ConstraintProto_BoolXor
	//	*ConstraintProto_IntDiv
	//	*ConstraintProto_IntMod
	//	*ConstraintProto_IntMax
	//	*ConstraintProto_LinMax
	//	*ConstraintProto_IntMin
	//	*ConstraintProto_LinMin
	//	*ConstraintProto_IntProd
	//	*ConstraintProto_Linear
	//	*ConstraintProto_AllDiff
	//	*ConstraintProto_Element
	//	*ConstraintProto_Circuit
	//	*ConstraintProto_Routes
	//	*ConstraintProto_CircuitCovering
	//	*ConstraintProto_Table
	//	*ConstraintProto_Automaton
	//	*ConstraintProto_Inverse
	//	*ConstraintProto_Reservoir
	//	*ConstraintProto_Interval
	//	*ConstraintProto_NoOverlap
	//	*ConstraintProto_NoOverlap_2D
	//	*ConstraintProto_Cumulative
	Constraint isConstraintProto_Constraint `protobuf_oneof:"constraint"`
}

func (x *ConstraintProto) Reset() {
	*x = ConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConstraintProto) ProtoMessage() {}

func (x *ConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConstraintProto.ProtoReflect.Descriptor instead.
func (*ConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{19}
}

func (x *ConstraintProto) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ConstraintProto) GetEnforcementLiteral() []int32 {
	if x != nil {
		return x.EnforcementLiteral
	}
	return nil
}

func (m *ConstraintProto) GetConstraint() isConstraintProto_Constraint {
	if m != nil {
		return m.Constraint
	}
	return nil
}

func (x *ConstraintProto) GetBoolOr() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_BoolOr); ok {
		return x.BoolOr
	}
	return nil
}

func (x *ConstraintProto) GetBoolAnd() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_BoolAnd); ok {
		return x.BoolAnd
	}
	return nil
}

func (x *ConstraintProto) GetAtMostOne() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_AtMostOne); ok {
		return x.AtMostOne
	}
	return nil
}

func (x *ConstraintProto) GetBoolXor() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_BoolXor); ok {
		return x.BoolXor
	}
	return nil
}

func (x *ConstraintProto) GetIntDiv() *IntegerArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntDiv); ok {
		return x.IntDiv
	}
	return nil
}

func (x *ConstraintProto) GetIntMod() *IntegerArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntMod); ok {
		return x.IntMod
	}
	return nil
}

func (x *ConstraintProto) GetIntMax() *IntegerArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntMax); ok {
		return x.IntMax
	}
	return nil
}

func (x *ConstraintProto) GetLinMax() *LinearArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_LinMax); ok {
		return x.LinMax
	}
	return nil
}

func (x *ConstraintProto) GetIntMin() *IntegerArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntMin); ok {
		return x.IntMin
	}
	return nil
}

func (x *ConstraintProto) GetLinMin() *LinearArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_LinMin); ok {
		return x.LinMin
	}
	return nil
}

func (x *ConstraintProto) GetIntProd() *IntegerArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntProd); ok {
		return x.IntProd
	}
	return nil
}

func (x *ConstraintProto) GetLinear() *LinearConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Linear); ok {
		return x.Linear
	}
	return nil
}

func (x *ConstraintProto) GetAllDiff() *AllDifferentConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_AllDiff); ok {
		return x.AllDiff
	}
	return nil
}

func (x *ConstraintProto) GetElement() *ElementConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Element); ok {
		return x.Element
	}
	return nil
}

func (x *ConstraintProto) GetCircuit() *CircuitConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Circuit); ok {
		return x.Circuit
	}
	return nil
}

func (x *ConstraintProto) GetRoutes() *RoutesConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Routes); ok {
		return x.Routes
	}
	return nil
}

func (x *ConstraintProto) GetCircuitCovering() *CircuitCoveringConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_CircuitCovering); ok {
		return x.CircuitCovering
	}
	return nil
}

func (x *ConstraintProto) GetTable() *TableConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Table); ok {
		return x.Table
	}
	return nil
}

func (x *ConstraintProto) GetAutomaton() *AutomatonConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Automaton); ok {
		return x.Automaton
	}
	return nil
}

func (x *ConstraintProto) GetInverse() *InverseConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Inverse); ok {
		return x.Inverse
	}
	return nil
}

func (x *ConstraintProto) GetReservoir() *ReservoirConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Reservoir); ok {
		return x.Reservoir
	}
	return nil
}

func (x *ConstraintProto) GetInterval() *IntervalConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Interval); ok {
		return x.Interval
	}
	return nil
}

func (x *ConstraintProto) GetNoOverlap() *NoOverlapConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_NoOverlap); ok {
		return x.NoOverlap
	}
	return nil
}

func (x *ConstraintProto) GetNoOverlap_2D() *NoOverlap2DConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_NoOverlap_2D); ok {
		return x.NoOverlap_2D
	}
	return nil
}

func (x *ConstraintProto) GetCumulative() *CumulativeConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Cumulative); ok {
		return x.Cumulative
	}
	return nil
}

type isConstraintProto_Constraint interface {
	isConstraintProto_Constraint()
}

type ConstraintProto_BoolOr struct {
	// The bool_or constraint forces at least one literal to be true.
	BoolOr *BoolArgumentProto `protobuf:"bytes,3,opt,name=bool_or,json=boolOr,proto3,oneof"`
}

type ConstraintProto_BoolAnd struct {
	// The bool_and constraint forces all of the literals to be true.
	//
	// This is a "redundant" constraint in the sense that this can easily be
	// encoded with many bool_or. It is just more space efficient and handled
	// slightly differently internally.
	BoolAnd *BoolArgumentProto `protobuf:"bytes,4,opt,name=bool_and,json=boolAnd,proto3,oneof"`
}

type ConstraintProto_AtMostOne struct {
	// The at_most_one constraint enforces that no more than one literal is
	// true at the same time. Note that an at most one constraint of length n
	// could be encoded with n bool_and constraint with n-1 term on the right
	// hand side. So in a sense, this constraint contribute directly to the
	// "implication-graph" or the 2-SAT part of the model.
	AtMostOne *BoolArgumentProto `protobuf:"bytes,26,opt,name=at_most_one,json=atMostOne,proto3,oneof"`
}

type ConstraintProto_BoolXor struct {
	// The bool_xor constraint forces an odd number of the literals to be true.
	BoolXor *BoolArgumentProto `protobuf:"bytes,5,opt,name=bool_xor,json=boolXor,proto3,oneof"`
}

type ConstraintProto_IntDiv struct {
	// The int_div constraint forces the target to equal vars[0] / vars[1].
	IntDiv *IntegerArgumentProto `protobuf:"bytes,7,opt,name=int_div,json=intDiv,proto3,oneof"`
}

type ConstraintProto_IntMod struct {
	// The int_mod constraint forces the target to equal vars[0] % vars[1].
	IntMod *IntegerArgumentProto `protobuf:"bytes,8,opt,name=int_mod,json=intMod,proto3,oneof"`
}

type ConstraintProto_IntMax struct {
	// The int_max constraint forces the target to equal the maximum of all
	// variables.
	// TODO(user): Remove int_max in favor of lin_max.
	IntMax *IntegerArgumentProto `protobuf:"bytes,9,opt,name=int_max,json=intMax,proto3,oneof"`
}

type ConstraintProto_LinMax struct {
	// The lin_max constraint forces the target to equal the maximum of all
	// linear expressions.
	LinMax *LinearArgumentProto `protobuf:"bytes,27,opt,name=lin_max,json=linMax,proto3,oneof"`
}

type ConstraintProto_IntMin struct {
	// The int_min constraint forces the target to equal the minimum of all
	// variables.
	// TODO(user): Remove int_min in favor of lin_min.
	IntMin *IntegerArgumentProto `protobuf:"bytes,10,opt,name=int_min,json=intMin,proto3,oneof"`
}

type ConstraintProto_LinMin struct {
	// The lin_min constraint forces the target to equal the minimum of all
	// linear expressions.
	LinMin *LinearArgumentProto `protobuf:"bytes,28,opt,name=lin_min,json=linMin,proto3,oneof"`
}

type ConstraintProto_IntProd struct {
	// The int_prod constraint forces the target to equal the product of all
	// variables.
	IntProd *IntegerArgumentProto `protobuf:"bytes,11,opt,name=int_prod,json=intProd,proto3,oneof"`
}

type ConstraintProto_Linear struct {
	// The linear constraint enforces a linear inequality among the variables,
	// such as 0 <= x + 2y <= 10.
	Linear *LinearConstraintProto `protobuf:"bytes,12,opt,name=linear,proto3,oneof"`
}

type ConstraintProto_AllDiff struct {
	// The all_diff constraint forces all variables to take different values.
	AllDiff *AllDifferentConstraintProto `protobuf:"bytes,13,opt,name=all_diff,json=allDiff,proto3,oneof"`
}

type ConstraintProto_Element struct {
	// The element constraint forces the variable with the given index
	// to be equal to the target.
	Element *ElementConstraintProto `protobuf:"bytes,14,opt,name=element,proto3,oneof"`
}

type ConstraintProto_Circuit struct {
	// The circuit constraint takes a graph and forces the arcs present
	// (with arc presence indicated by a literal) to form a unique cycle.
	Circuit *CircuitConstraintProto `protobuf:"bytes,15,opt,name=circuit,proto3,oneof"`
}

type ConstraintProto_Routes struct {
	// The routes constraint implements the vehicle routing problem.
	Routes *RoutesConstraintProto `protobuf:"bytes,23,opt,name=routes,proto3,oneof"`
}

type ConstraintProto_CircuitCovering struct {
	// The circuit_covering constraint is similar to the circuit constraint,
	// but allows multiple non-overlapping cycles instead of just one.
	CircuitCovering *CircuitCoveringConstraintProto `protobuf:"bytes,25,opt,name=circuit_covering,json=circuitCovering,proto3,oneof"`
}

type ConstraintProto_Table struct {
	// The table constraint enforces what values a tuple of variables may
	// take.
	Table *TableConstraintProto `protobuf:"bytes,16,opt,name=table,proto3,oneof"`
}

type ConstraintProto_Automaton struct {
	// The automaton constraint forces a sequence of variables to be accepted
	// by an automaton.
	Automaton *AutomatonConstraintProto `protobuf:"bytes,17,opt,name=automaton,proto3,oneof"`
}

type ConstraintProto_Inverse struct {
	// The inverse constraint forces two arrays to be inverses of each other:
	// the values of one are the indices of the other, and vice versa.
	Inverse *InverseConstraintProto `protobuf:"bytes,18,opt,name=inverse,proto3,oneof"`
}

type ConstraintProto_Reservoir struct {
	// The reservoir constraint forces the sum of a set of active demands
	// to always be between a specified minimum and maximum value during
	// specific times.
	Reservoir *ReservoirConstraintProto `protobuf:"bytes,24,opt,name=reservoir,proto3,oneof"`
}

type ConstraintProto_Interval struct {
	// The interval constraint takes a start, end, and size, and forces
	// start + size == end.
	Interval *IntervalConstraintProto `protobuf:"bytes,19,opt,name=interval,proto3,oneof"`
}

type ConstraintProto_NoOverlap struct {
	// The no_overlap constraint prevents a set of intervals from
	// overlapping; in scheduling, this is called a disjunctive
	// constraint.
	NoOverlap *NoOverlapConstraintProto `protobuf:"bytes,20,opt,name=no_overlap,json=noOverlap,proto3,oneof"`
}

type ConstraintProto_NoOverlap_2D struct {
	// The no_overlap_2d constraint prevents a set of boxes from overlapping.
	NoOverlap_2D *NoOverlap2DConstraintProto `protobuf:"bytes,21,opt,name=no_overlap_2d,json=noOverlap2d,proto3,oneof"`
}

type ConstraintProto_Cumulative struct {
	// The cumulative constraint ensures that for any integer point, the sum
	// of the demands of the intervals containing that point does not exceed
	// the capacity.
	Cumulative *CumulativeConstraintProto `protobuf:"bytes,22,opt,name=cumulative,proto3,oneof"`
}

func (*ConstraintProto_BoolOr) isConstraintProto_Constraint() {}

func (*ConstraintProto_BoolAnd) isConstraintProto_Constraint() {}

func (*ConstraintProto_AtMostOne) isConstraintProto_Constraint() {}

func (*ConstraintProto_BoolXor) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntDiv) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntMod) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntMax) isConstraintProto_Constraint() {}

func (*ConstraintProto_LinMax) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntMin) isConstraintProto_Constraint() {}

func (*ConstraintProto_LinMin) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntProd) isConstraintProto_Constraint() {}

func (*ConstraintProto_Linear) isConstraintProto_Constraint() {}

func (*ConstraintProto_AllDiff) isConstraintProto_Constraint() {}

func (*ConstraintProto_Element) isConstraintProto_Constraint() {}

func (*ConstraintProto_Circuit) isConstraintProto_Constraint() {}

func (*ConstraintProto_Routes) isConstraintProto_Constraint() {}

func (*ConstraintProto_CircuitCovering) isConstraintProto_Constraint() {}

func (*ConstraintProto_Table) isConstraintProto_Constraint() {}

func (*ConstraintProto_Automaton) isConstraintProto_Constraint() {}

func (*ConstraintProto_Inverse) isConstraintProto_Constraint() {}

func (*ConstraintProto_Reservoir) isConstraintProto_Constraint() {}

func (*ConstraintProto_Interval) isConstraintProto_Constraint() {}

func (*ConstraintProto_NoOverlap) isConstraintProto_Constraint() {}

func (*ConstraintProto_NoOverlap_2D) isConstraintProto_Constraint() {}

func (*ConstraintProto_Cumulative) isConstraintProto_Constraint() {}

// Optimization objective.
//
// This is in a message because decision problems don't have any objective.
type CpObjectiveProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The linear terms of the objective to minimize.
	// For a maximization problem, one can negate all coefficients in the
	// objective and set a scaling_factor to -1.
	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []int64 `protobuf:"varint,4,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	// The displayed objective is always:
	//   scaling_factor * (sum(coefficients[i] * objective_vars[i]) + offset).
	// This is needed to have a consistent objective after presolve or when
	// scaling a double problem to express it with integers.
	//
	// Note that if scaling_factor is zero, then it is assumed to be 1, so that by
	// default these fields have no effect.
	Offset        float64 `protobuf:"fixed64,2,opt,name=offset,proto3" json:"offset,omitempty"`
	ScalingFactor float64 `protobuf:"fixed64,3,opt,name=scaling_factor,json=scalingFactor,proto3" json:"scaling_factor,omitempty"`
	// If non-empty, only look for an objective value in the given domain.
	// Note that this does not depend on the offset or scaling factor, it is a
	// domain on the sum of the objective terms only.
	Domain []int64 `protobuf:"varint,5,rep,packed,name=domain,proto3" json:"domain,omitempty"`
}

func (x *CpObjectiveProto) Reset() {
	*x = CpObjectiveProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CpObjectiveProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpObjectiveProto) ProtoMessage() {}

func (x *CpObjectiveProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpObjectiveProto.ProtoReflect.Descriptor instead.
func (*CpObjectiveProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{20}
}

func (x *CpObjectiveProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *CpObjectiveProto) GetCoeffs() []int64 {
	if x != nil {
		return x.Coeffs
	}
	return nil
}

func (x *CpObjectiveProto) GetOffset() float64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *CpObjectiveProto) GetScalingFactor() float64 {
	if x != nil {
		return x.ScalingFactor
	}
	return 0
}

func (x *CpObjectiveProto) GetDomain() []int64 {
	if x != nil {
		return x.Domain
	}
	return nil
}

// Define the strategy to follow when the solver needs to take a new decision.
// Note that this strategy is only defined on a subset of variables.
type DecisionStrategyProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The variables to be considered for the next decision. The order matter and
	// is always used as a tie-breaker after the variable selection strategy
	// criteria defined below.
	Variables                 []int32                                         `protobuf:"varint,1,rep,packed,name=variables,proto3" json:"variables,omitempty"`
	VariableSelectionStrategy DecisionStrategyProto_VariableSelectionStrategy `protobuf:"varint,2,opt,name=variable_selection_strategy,json=variableSelectionStrategy,proto3,enum=operations_research.sat.DecisionStrategyProto_VariableSelectionStrategy" json:"variable_selection_strategy,omitempty"`
	DomainReductionStrategy   DecisionStrategyProto_DomainReductionStrategy   `protobuf:"varint,3,opt,name=domain_reduction_strategy,json=domainReductionStrategy,proto3,enum=operations_research.sat.DecisionStrategyProto_DomainReductionStrategy" json:"domain_reduction_strategy,omitempty"`
	Transformations           []*DecisionStrategyProto_AffineTransformation   `protobuf:"bytes,4,rep,name=transformations,proto3" json:"transformations,omitempty"`
}

func (x *DecisionStrategyProto) Reset() {
	*x = DecisionStrategyProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DecisionStrategyProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DecisionStrategyProto) ProtoMessage() {}

func (x *DecisionStrategyProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DecisionStrategyProto.ProtoReflect.Descriptor instead.
func (*DecisionStrategyProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{21}
}

func (x *DecisionStrategyProto) GetVariables() []int32 {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *DecisionStrategyProto) GetVariableSelectionStrategy() DecisionStrategyProto_VariableSelectionStrategy {
	if x != nil {
		return x.VariableSelectionStrategy
	}
	return DecisionStrategyProto_CHOOSE_FIRST
}

func (x *DecisionStrategyProto) GetDomainReductionStrategy() DecisionStrategyProto_DomainReductionStrategy {
	if x != nil {
		return x.DomainReductionStrategy
	}
	return DecisionStrategyProto_SELECT_MIN_VALUE
}

func (x *DecisionStrategyProto) GetTransformations() []*DecisionStrategyProto_AffineTransformation {
	if x != nil {
		return x.Transformations
	}
	return nil
}

// This message encodes a partial (or full) assignment of the variables of a
// CpModelProto. The variable indices should be unique and valid variable
// indices.
type PartialVariableAssignment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Values []int64 `protobuf:"varint,2,rep,packed,name=values,proto3" json:"values,omitempty"`
}

func (x *PartialVariableAssignment) Reset() {
	*x = PartialVariableAssignment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PartialVariableAssignment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartialVariableAssignment) ProtoMessage() {}

func (x *PartialVariableAssignment) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartialVariableAssignment.ProtoReflect.Descriptor instead.
func (*PartialVariableAssignment) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{22}
}

func (x *PartialVariableAssignment) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *PartialVariableAssignment) GetValues() []int64 {
	if x != nil {
		return x.Values
	}
	return nil
}

// A constraint programming problem.
type CpModelProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The associated Protos should be referred by their index in these fields.
	Variables   []*IntegerVariableProto `protobuf:"bytes,2,rep,name=variables,proto3" json:"variables,omitempty"`
	Constraints []*ConstraintProto      `protobuf:"bytes,3,rep,name=constraints,proto3" json:"constraints,omitempty"`
	// The objective to minimize. Can be empty for pure decision problems.
	Objective *CpObjectiveProto `protobuf:"bytes,4,opt,name=objective,proto3" json:"objective,omitempty"`
	// Defines the strategy that the solver should follow when the
	// search_branching parameter is set to FIXED_SEARCH. Note that this strategy
	// is also used as a heuristic when we are not in fixed search.
	//
	// Advanced Usage: if not all variables appears and the parameter
	// "instantiate_all_variables" is set to false, then the solver will not try
	// to instantiate the variables that do not appear. Thus, at the end of the
	// search, not all variables may be fixed and this is why we have the
	// solution_lower_bounds and solution_upper_bounds fields in the
	// CpSolverResponse.
	SearchStrategy []*DecisionStrategyProto `protobuf:"bytes,5,rep,name=search_strategy,json=searchStrategy,proto3" json:"search_strategy,omitempty"`
	// Solution hint.
	//
	// If a feasible or almost-feasible solution to the problem is already known,
	// it may be helpful to pass it to the solver so that it can be used. The
	// solver will try to use this information to create its initial feasible
	// solution.
	//
	// Note that it may not always be faster to give a hint like this to the
	// solver. There is also no guarantee that the solver will use this hint or
	// try to return a solution "close" to this assignment in case of multiple
	// optimal solutions.
	SolutionHint *PartialVariableAssignment `protobuf:"bytes,6,opt,name=solution_hint,json=solutionHint,proto3" json:"solution_hint,omitempty"`
	// A list of literals. The model will be solved assuming all these literals
	// are true. Compared to just fixing the domain of these literals, using this
	// mechanism is slower but allows in case the model is INFEASIBLE to get a
	// potentially small subset of them that can be used to explain the
	// infeasibility.
	//
	// Think (IIS), except when you are only concerned by the provided
	// assumptions. This is powerful as it allows to group a set of logicially
	// related constraint under only one enforcement literal which can potentially
	// give you a good and interpretable explanation for infeasiblity.
	//
	// Such infeasibility explanation will be available in the
	// sufficient_assumptions_for_infeasibility response field.
	Assumptions []int32 `protobuf:"varint,7,rep,packed,name=assumptions,proto3" json:"assumptions,omitempty"`
}

func (x *CpModelProto) Reset() {
	*x = CpModelProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CpModelProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpModelProto) ProtoMessage() {}

func (x *CpModelProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpModelProto.ProtoReflect.Descriptor instead.
func (*CpModelProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{23}
}

func (x *CpModelProto) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CpModelProto) GetVariables() []*IntegerVariableProto {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *CpModelProto) GetConstraints() []*ConstraintProto {
	if x != nil {
		return x.Constraints
	}
	return nil
}

func (x *CpModelProto) GetObjective() *CpObjectiveProto {
	if x != nil {
		return x.Objective
	}
	return nil
}

func (x *CpModelProto) GetSearchStrategy() []*DecisionStrategyProto {
	if x != nil {
		return x.SearchStrategy
	}
	return nil
}

func (x *CpModelProto) GetSolutionHint() *PartialVariableAssignment {
	if x != nil {
		return x.SolutionHint
	}
	return nil
}

func (x *CpModelProto) GetAssumptions() []int32 {
	if x != nil {
		return x.Assumptions
	}
	return nil
}

// The response returned by a solver trying to solve a CpModelProto.
//
// TODO(user): support returning multiple solutions. Look at the Stubby
// streaming API as we probably wants to get them as they are found.
// Next id: 24
type CpSolverResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The status of the solve.
	Status CpSolverStatus `protobuf:"varint,1,opt,name=status,proto3,enum=operations_research.sat.CpSolverStatus" json:"status,omitempty"`
	// A feasible solution to the given problem. Depending on the returned status
	// it may be optimal or just feasible. This is in one-to-one correspondence
	// with a CpModelProto::variables repeated field and list the values of all
	// the variables.
	Solution []int64 `protobuf:"varint,2,rep,packed,name=solution,proto3" json:"solution,omitempty"`
	// Only make sense for an optimization problem. The objective value of the
	// returned solution if it is non-empty. If there is no solution, then for a
	// minimization problem, this will be an upper-bound of the objective of any
	// feasible solution, and a lower-bound for a maximization problem.
	ObjectiveValue float64 `protobuf:"fixed64,3,opt,name=objective_value,json=objectiveValue,proto3" json:"objective_value,omitempty"`
	// Only make sense for an optimization problem. A proven lower-bound on the
	// objective for a minimization problem, or a proven upper-bound for a
	// maximization problem.
	BestObjectiveBound float64 `protobuf:"fixed64,4,opt,name=best_objective_bound,json=bestObjectiveBound,proto3" json:"best_objective_bound,omitempty"`
	// Advanced usage.
	//
	// If the problem has some variables that are not fixed at the end of the
	// search (because of a particular search strategy in the CpModelProto) then
	// this will be used instead of filling the solution above. The two fields
	// will then contains the lower and upper bounds of each variable as they were
	// when the best "solution" was found.
	SolutionLowerBounds []int64 `protobuf:"varint,18,rep,packed,name=solution_lower_bounds,json=solutionLowerBounds,proto3" json:"solution_lower_bounds,omitempty"`
	SolutionUpperBounds []int64 `protobuf:"varint,19,rep,packed,name=solution_upper_bounds,json=solutionUpperBounds,proto3" json:"solution_upper_bounds,omitempty"`
	// Advanced usage.
	//
	// If the option fill_tightened_domains_in_response is set, then this field
	// will be a copy of the CpModelProto.variables where each domain has been
	// reduced using the information the solver was able to derive. Note that this
	// is only filled with the info derived during a normal search and we do not
	// have any dedicated algorithm to improve it.
	//
	// If the problem is a feasibility problem, then these bounds will be valid
	// for any feasible solution. If the problem is an optimization problem, then
	// these bounds will only be valid for any OPTIMAL solutions, it can exclude
	// sub-optimal feasible ones.
	TightenedVariables []*IntegerVariableProto `protobuf:"bytes,21,rep,name=tightened_variables,json=tightenedVariables,proto3" json:"tightened_variables,omitempty"`
	// A subset of the model "assumptions" field. This will only be filled if the
	// status is INFEASIBLE. This subset of assumption will be enough to still get
	// an infeasible problem.
	//
	// This is related to what is called the irreducible inconsistent subsystem or
	// IIS. Except one is only concerned by the provided assumptions. There is
	// also no guarantee that we return an irreducible (aka minimal subset).
	// However, this is based on SAT explanation and there is a good chance it is
	// not too large.
	//
	// If you really want a minimal subset, a possible way to get one is by
	// changing your model to minimize the number of assumptions at false, but
	// this is likely an harder problem to solve.
	//
	// TODO(user): Allows for returning multiple core at once.
	SufficientAssumptionsForInfeasibility []int32 `protobuf:"varint,23,rep,packed,name=sufficient_assumptions_for_infeasibility,json=sufficientAssumptionsForInfeasibility,proto3" json:"sufficient_assumptions_for_infeasibility,omitempty"`
	// This will be true iff the solver was asked to find all solutions to a
	// satisfiability problem (or all optimal solutions to an optimization
	// problem), and it was successful in doing so.
	//
	// TODO(user): Remove as we also use the OPTIMAL vs FEASIBLE status for that.
	AllSolutionsWereFound bool `protobuf:"varint,5,opt,name=all_solutions_were_found,json=allSolutionsWereFound,proto3" json:"all_solutions_were_found,omitempty"`
	// Some statistics about the solve.
	NumBooleans            int64   `protobuf:"varint,10,opt,name=num_booleans,json=numBooleans,proto3" json:"num_booleans,omitempty"`
	NumConflicts           int64   `protobuf:"varint,11,opt,name=num_conflicts,json=numConflicts,proto3" json:"num_conflicts,omitempty"`
	NumBranches            int64   `protobuf:"varint,12,opt,name=num_branches,json=numBranches,proto3" json:"num_branches,omitempty"`
	NumBinaryPropagations  int64   `protobuf:"varint,13,opt,name=num_binary_propagations,json=numBinaryPropagations,proto3" json:"num_binary_propagations,omitempty"`
	NumIntegerPropagations int64   `protobuf:"varint,14,opt,name=num_integer_propagations,json=numIntegerPropagations,proto3" json:"num_integer_propagations,omitempty"`
	WallTime               float64 `protobuf:"fixed64,15,opt,name=wall_time,json=wallTime,proto3" json:"wall_time,omitempty"`
	UserTime               float64 `protobuf:"fixed64,16,opt,name=user_time,json=userTime,proto3" json:"user_time,omitempty"`
	DeterministicTime      float64 `protobuf:"fixed64,17,opt,name=deterministic_time,json=deterministicTime,proto3" json:"deterministic_time,omitempty"`
	PrimalIntegral         float64 `protobuf:"fixed64,22,opt,name=primal_integral,json=primalIntegral,proto3" json:"primal_integral,omitempty"`
	// Additional information about how the solution was found.
	SolutionInfo string `protobuf:"bytes,20,opt,name=solution_info,json=solutionInfo,proto3" json:"solution_info,omitempty"`
}

func (x *CpSolverResponse) Reset() {
	*x = CpSolverResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CpSolverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpSolverResponse) ProtoMessage() {}

func (x *CpSolverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpSolverResponse.ProtoReflect.Descriptor instead.
func (*CpSolverResponse) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{24}
}

func (x *CpSolverResponse) GetStatus() CpSolverStatus {
	if x != nil {
		return x.Status
	}
	return CpSolverStatus_UNKNOWN
}

func (x *CpSolverResponse) GetSolution() []int64 {
	if x != nil {
		return x.Solution
	}
	return nil
}

func (x *CpSolverResponse) GetObjectiveValue() float64 {
	if x != nil {
		return x.ObjectiveValue
	}
	return 0
}

func (x *CpSolverResponse) GetBestObjectiveBound() float64 {
	if x != nil {
		return x.BestObjectiveBound
	}
	return 0
}

func (x *CpSolverResponse) GetSolutionLowerBounds() []int64 {
	if x != nil {
		return x.SolutionLowerBounds
	}
	return nil
}

func (x *CpSolverResponse) GetSolutionUpperBounds() []int64 {
	if x != nil {
		return x.SolutionUpperBounds
	}
	return nil
}

func (x *CpSolverResponse) GetTightenedVariables() []*IntegerVariableProto {
	if x != nil {
		return x.TightenedVariables
	}
	return nil
}

func (x *CpSolverResponse) GetSufficientAssumptionsForInfeasibility() []int32 {
	if x != nil {
		return x.SufficientAssumptionsForInfeasibility
	}
	return nil
}

func (x *CpSolverResponse) GetAllSolutionsWereFound() bool {
	if x != nil {
		return x.AllSolutionsWereFound
	}
	return false
}

func (x *CpSolverResponse) GetNumBooleans() int64 {
	if x != nil {
		return x.NumBooleans
	}
	return 0
}

func (x *CpSolverResponse) GetNumConflicts() int64 {
	if x != nil {
		return x.NumConflicts
	}
	return 0
}

func (x *CpSolverResponse) GetNumBranches() int64 {
	if x != nil {
		return x.NumBranches
	}
	return 0
}

func (x *CpSolverResponse) GetNumBinaryPropagations() int64 {
	if x != nil {
		return x.NumBinaryPropagations
	}
	return 0
}

func (x *CpSolverResponse) GetNumIntegerPropagations() int64 {
	if x != nil {
		return x.NumIntegerPropagations
	}
	return 0
}

func (x *CpSolverResponse) GetWallTime() float64 {
	if x != nil {
		return x.WallTime
	}
	return 0
}

func (x *CpSolverResponse) GetUserTime() float64 {
	if x != nil {
		return x.UserTime
	}
	return 0
}

func (x *CpSolverResponse) GetDeterministicTime() float64 {
	if x != nil {
		return x.DeterministicTime
	}
	return 0
}

func (x *CpSolverResponse) GetPrimalIntegral() float64 {
	if x != nil {
		return x.PrimalIntegral
	}
	return 0
}

func (x *CpSolverResponse) GetSolutionInfo() string {
	if x != nil {
		return x.SolutionInfo
	}
	return ""
}

// Advanced usage. Some of the variable listed above may have been transformed
// by the presolve so this is needed to properly follow the given selection
// strategy. Instead of using a value X from one of the variable listed here,
// we will use positive_coeff * X + offset instead.
type DecisionStrategyProto_AffineTransformation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Var           int32 `protobuf:"varint,1,opt,name=var,proto3" json:"var,omitempty"`
	Offset        int64 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	PositiveCoeff int64 `protobuf:"varint,3,opt,name=positive_coeff,json=positiveCoeff,proto3" json:"positive_coeff,omitempty"`
}

func (x *DecisionStrategyProto_AffineTransformation) Reset() {
	*x = DecisionStrategyProto_AffineTransformation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DecisionStrategyProto_AffineTransformation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DecisionStrategyProto_AffineTransformation) ProtoMessage() {}

func (x *DecisionStrategyProto_AffineTransformation) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DecisionStrategyProto_AffineTransformation.ProtoReflect.Descriptor instead.
func (*DecisionStrategyProto_AffineTransformation) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{21, 0}
}

func (x *DecisionStrategyProto_AffineTransformation) GetVar() int32 {
	if x != nil {
		return x.Var
	}
	return 0
}

func (x *DecisionStrategyProto_AffineTransformation) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *DecisionStrategyProto_AffineTransformation) GetPositiveCoeff() int64 {
	if x != nil {
		return x.PositiveCoeff
	}
	return 0
}

var File_cp_model_proto protoreflect.FileDescriptor

var file_cp_model_proto_rawDesc = []byte{
	0x0a, 0x0e, 0x63, 0x70, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x17, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x22, 0x42, 0x0a, 0x14, 0x49, 0x6e, 0x74,
	0x65, 0x67, 0x65, 0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x22, 0x2f, 0x0a,
	0x11, 0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x22, 0x42,
	0x0a, 0x14, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e,
	0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x12,
	0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61,
	0x72, 0x73, 0x22, 0x5b, 0x0a, 0x15, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76,
	0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x12,
	0x16, 0x0a, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x03, 0x52,
	0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22,
	0xa3, 0x01, 0x0a, 0x13, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x46, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65,
	0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61,
	0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12,
	0x44, 0x0a, 0x05, 0x65, 0x78, 0x70, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45,
	0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x05,
	0x65, 0x78, 0x70, 0x72, 0x73, 0x22, 0x31, 0x0a, 0x1b, 0x41, 0x6c, 0x6c, 0x44, 0x69, 0x66, 0x66,
	0x65, 0x72, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x22, 0x5b, 0x0a, 0x15, 0x4c, 0x69, 0x6e, 0x65,
	0x61, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52,
	0x04, 0x76, 0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x12, 0x16, 0x0a,
	0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x64,
	0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x22, 0x5a, 0x0a, 0x16, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x14, 0x0a, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05,
	0x69, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x12, 0x0a,
	0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72,
	0x73, 0x22, 0x55, 0x0a, 0x17, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x43, 0x6f, 0x6e,
	0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x05,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x73, 0x74, 0x61,
	0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x03, 0x65, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x22, 0x38, 0x0a, 0x18, 0x4e, 0x6f, 0x4f, 0x76,
	0x65, 0x72, 0x6c, 0x61, 0x70, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x73, 0x22, 0xa5, 0x01, 0x0a, 0x1a, 0x4e, 0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70,
	0x32, 0x44, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x1f, 0x0a, 0x0b, 0x78, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x78, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x79, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x79, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76,
	0x61, 0x6c, 0x73, 0x12, 0x45, 0x0a, 0x20, 0x62, 0x6f, 0x78, 0x65, 0x73, 0x5f, 0x77, 0x69, 0x74,
	0x68, 0x5f, 0x6e, 0x75, 0x6c, 0x6c, 0x5f, 0x61, 0x72, 0x65, 0x61, 0x5f, 0x63, 0x61, 0x6e, 0x5f,
	0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1b, 0x62,
	0x6f, 0x78, 0x65, 0x73, 0x57, 0x69, 0x74, 0x68, 0x4e, 0x75, 0x6c, 0x6c, 0x41, 0x72, 0x65, 0x61,
	0x43, 0x61, 0x6e, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x22, 0x6f, 0x0a, 0x19, 0x43, 0x75,
	0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63,
	0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63,
	0x69, 0x74, 0x79, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x73, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x05, 0x52, 0x07, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x22, 0x9e, 0x01, 0x0a, 0x18,
	0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x69, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
	0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f,
	0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x6d, 0x69, 0x6e,
	0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x65, 0x76,
	0x65, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x76,
	0x65, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x05, 0x52, 0x05, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x6d, 0x61,
	0x6e, 0x64, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x03, 0x52, 0x07, 0x64, 0x65, 0x6d, 0x61, 0x6e,
	0x64, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x73, 0x18, 0x05, 0x20,
	0x03, 0x28, 0x05, 0x52, 0x07, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x73, 0x22, 0x60, 0x0a, 0x16,
	0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e,
	0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x14, 0x0a, 0x05,
	0x68, 0x65, 0x61, 0x64, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x68, 0x65, 0x61,
	0x64, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x18, 0x05,
	0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x22, 0x95,
	0x01, 0x0a, 0x15, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
	0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x69, 0x6c,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x14,
	0x0a, 0x05, 0x68, 0x65, 0x61, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x68,
	0x65, 0x61, 0x64, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73,
	0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
	0x05, 0x52, 0x07, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x61,
	0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x63, 0x61,
	0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x22, 0x67, 0x0a, 0x1e, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69,
	0x74, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
	0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x6e, 0x65, 0x78, 0x74,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x12, 0x2f,
	0x0a, 0x13, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x75, 0x69, 0x73, 0x68, 0x65, 0x64, 0x5f,
	0x6e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x12, 0x64, 0x69, 0x73,
	0x74, 0x69, 0x6e, 0x67, 0x75, 0x69, 0x73, 0x68, 0x65, 0x64, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x22,
	0x5c, 0x0a, 0x14, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64, 0x22, 0x50, 0x0a,
	0x16, 0x49, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x19, 0x0a, 0x08, 0x66, 0x5f, 0x64, 0x69, 0x72,
	0x65, 0x63, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x07, 0x66, 0x44, 0x69, 0x72, 0x65,
	0x63, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x5f, 0x69, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x66, 0x49, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x22,
	0xf5, 0x01, 0x0a, 0x18, 0x41, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x6f, 0x6e, 0x43, 0x6f, 0x6e,
	0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x25, 0x0a, 0x0e,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x74,
	0x61, 0x74, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x61,
	0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x03, 0x52, 0x0b, 0x66, 0x69, 0x6e, 0x61, 0x6c,
	0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x12, 0x27, 0x0a, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x61, 0x69, 0x6c, 0x18, 0x04, 0x20, 0x03, 0x28, 0x03, 0x52,
	0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x61, 0x69, 0x6c, 0x12,
	0x27, 0x0a, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x68, 0x65,
	0x61, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x03, 0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x48, 0x65, 0x61, 0x64, 0x12, 0x29, 0x0a, 0x10, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x06, 0x20, 0x03,
	0x28, 0x03, 0x52, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x61,
	0x62, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28,
	0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x22, 0x87, 0x10, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x73,
	0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
	0x2f, 0x0a, 0x13, 0x65, 0x6e, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x6c,
	0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x12, 0x65, 0x6e,
	0x66, 0x6f, 0x72, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c,
	0x12, 0x45, 0x0a, 0x07, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72,
	0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x42, 0x6f, 0x6f, 0x6c,
	0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52,
	0x06, 0x62, 0x6f, 0x6f, 0x6c, 0x4f, 0x72, 0x12, 0x47, 0x0a, 0x08, 0x62, 0x6f, 0x6f, 0x6c, 0x5f,
	0x61, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x73, 0x61, 0x74, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x07, 0x62, 0x6f, 0x6f, 0x6c, 0x41, 0x6e, 0x64,
	0x12, 0x4c, 0x0a, 0x0b, 0x61, 0x74, 0x5f, 0x6d, 0x6f, 0x73, 0x74, 0x5f, 0x6f, 0x6e, 0x65, 0x18,
	0x1a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e,
	0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x48, 0x00, 0x52, 0x09, 0x61, 0x74, 0x4d, 0x6f, 0x73, 0x74, 0x4f, 0x6e, 0x65, 0x12, 0x47,
	0x0a, 0x08, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x78, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x41,
	0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x07,
	0x62, 0x6f, 0x6f, 0x6c, 0x58, 0x6f, 0x72, 0x12, 0x48, 0x0a, 0x07, 0x69, 0x6e, 0x74, 0x5f, 0x64,
	0x69, 0x76, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x69, 0x6e, 0x74, 0x44, 0x69,
	0x76, 0x12, 0x48, 0x0a, 0x07, 0x69, 0x6e, 0x74, 0x5f, 0x6d, 0x6f, 0x64, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f,
	0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74,
	0x65, 0x67, 0x65, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x48, 0x00, 0x52, 0x06, 0x69, 0x6e, 0x74, 0x4d, 0x6f, 0x64, 0x12, 0x48, 0x0a, 0x07, 0x69,
	0x6e, 0x74, 0x5f, 0x6d, 0x61, 0x78, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x41, 0x72,
	0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x69,
	0x6e, 0x74, 0x4d, 0x61, 0x78, 0x12, 0x47, 0x0a, 0x07, 0x6c, 0x69, 0x6e, 0x5f, 0x6d, 0x61, 0x78,
	0x18, 0x1b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74,
	0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x6c, 0x69, 0x6e, 0x4d, 0x61, 0x78, 0x12, 0x48,
	0x0a, 0x07, 0x69, 0x6e, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65,
	0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00,
	0x52, 0x06, 0x69, 0x6e, 0x74, 0x4d, 0x69, 0x6e, 0x12, 0x47, 0x0a, 0x07, 0x6c, 0x69, 0x6e, 0x5f,
	0x6d, 0x69, 0x6e, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x6c, 0x69, 0x6e, 0x4d, 0x69,
	0x6e, 0x12, 0x4a, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x64, 0x18, 0x0b, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e,
	0x74, 0x65, 0x67, 0x65, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x48, 0x00, 0x52, 0x07, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x64, 0x12, 0x48, 0x0a,
	0x06, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x43, 0x6f,
	0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52,
	0x06, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x12, 0x51, 0x0a, 0x08, 0x61, 0x6c, 0x6c, 0x5f, 0x64,
	0x69, 0x66, 0x66, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x73, 0x61, 0x74, 0x2e, 0x41, 0x6c, 0x6c, 0x44, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48,
	0x00, 0x52, 0x07, 0x61, 0x6c, 0x6c, 0x44, 0x69, 0x66, 0x66, 0x12, 0x4b, 0x0a, 0x07, 0x65, 0x6c,
	0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e,
	0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x07,
	0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x4b, 0x0a, 0x07, 0x63, 0x69, 0x72, 0x63, 0x75,
	0x69, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x07, 0x63, 0x69, 0x72,
	0x63, 0x75, 0x69, 0x74, 0x12, 0x48, 0x0a, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x17,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x64,
	0x0a, 0x10, 0x63, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x69,
	0x6e, 0x67, 0x18, 0x19, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x69,
	0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x48, 0x00, 0x52, 0x0f, 0x63, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x43, 0x6f, 0x76, 0x65,
	0x72, 0x69, 0x6e, 0x67, 0x12, 0x45, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x10, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x54, 0x61,
	0x62, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x48, 0x00, 0x52, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x51, 0x0a, 0x09, 0x61,
	0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x6f, 0x6e, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74,
	0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x48, 0x00, 0x52, 0x09, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x6f, 0x6e, 0x12, 0x4b,
	0x0a, 0x07, 0x69, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x18, 0x12, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x2f, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x76, 0x65, 0x72, 0x73,
	0x65, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x48, 0x00, 0x52, 0x07, 0x69, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x12, 0x51, 0x0a, 0x09, 0x72,
	0x65, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x69, 0x72, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x6f,
	0x69, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x48, 0x00, 0x52, 0x09, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x69, 0x72, 0x12, 0x4e,
	0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x13, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x30, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x72,
	0x76, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x48, 0x00, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x52,
	0x0a, 0x0a, 0x6e, 0x6f, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x18, 0x14, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x31, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f,
	0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4e, 0x6f, 0x4f,
	0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x09, 0x6e, 0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c,
	0x61, 0x70, 0x12, 0x59, 0x0a, 0x0d, 0x6e, 0x6f, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70,
	0x5f, 0x32, 0x64, 0x18, 0x15, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x73, 0x61, 0x74, 0x2e, 0x4e, 0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x32, 0x44, 0x43,
	0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00,
	0x52, 0x0b, 0x6e, 0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x32, 0x64, 0x12, 0x54, 0x0a,
	0x0a, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x18, 0x16, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72,
	0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x43, 0x75, 0x6d, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x0a, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74,
	0x69, 0x76, 0x65, 0x42, 0x0c, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e,
	0x74, 0x22, 0x95, 0x01, 0x0a, 0x10, 0x43, 0x70, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76,
	0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f,
	0x65, 0x66, 0x66, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x63, 0x6f, 0x65, 0x66,
	0x66, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x63,
	0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x0d, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x46, 0x61, 0x63, 0x74, 0x6f,
	0x72, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x05, 0x20, 0x03, 0x28,
	0x03, 0x52, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x22, 0xc3, 0x06, 0x0a, 0x15, 0x44, 0x65,
	0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x09, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65,
	0x73, 0x12, 0x88, 0x01, 0x0a, 0x1b, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73,
	0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x48, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61,
	0x74, 0x2e, 0x44, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65,
	0x67, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65,
	0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67,
	0x79, 0x52, 0x19, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x82, 0x01, 0x0a,
	0x19, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x72, 0x65, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x46, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x44, 0x65, 0x63, 0x69, 0x73,
	0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x2e, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x52, 0x65, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x17, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e,
	0x52, 0x65, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67,
	0x79, 0x12, 0x6d, 0x0a, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x43, 0x2e, 0x6f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x2e, 0x73, 0x61, 0x74, 0x2e, 0x44, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72,
	0x61, 0x74, 0x65, 0x67, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x41, 0x66, 0x66, 0x69, 0x6e,
	0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x1a, 0x67, 0x0a, 0x14, 0x41, 0x66, 0x66, 0x69, 0x6e, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x76, 0x61, 0x72, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x76, 0x61, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66,
	0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73,
	0x65, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x63,
	0x6f, 0x65, 0x66, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x65, 0x66, 0x66, 0x22, 0x94, 0x01, 0x0a, 0x19, 0x56, 0x61,
	0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53,
	0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x10, 0x0a, 0x0c, 0x43, 0x48, 0x4f, 0x4f, 0x53,
	0x45, 0x5f, 0x46, 0x49, 0x52, 0x53, 0x54, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11, 0x43, 0x48, 0x4f,
	0x4f, 0x53, 0x45, 0x5f, 0x4c, 0x4f, 0x57, 0x45, 0x53, 0x54, 0x5f, 0x4d, 0x49, 0x4e, 0x10, 0x01,
	0x12, 0x16, 0x0a, 0x12, 0x43, 0x48, 0x4f, 0x4f, 0x53, 0x45, 0x5f, 0x48, 0x49, 0x47, 0x48, 0x45,
	0x53, 0x54, 0x5f, 0x4d, 0x41, 0x58, 0x10, 0x02, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48, 0x4f, 0x4f,
	0x53, 0x45, 0x5f, 0x4d, 0x49, 0x4e, 0x5f, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, 0x5f, 0x53, 0x49,
	0x5a, 0x45, 0x10, 0x03, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48, 0x4f, 0x4f, 0x53, 0x45, 0x5f, 0x4d,
	0x41, 0x58, 0x5f, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, 0x5f, 0x53, 0x49, 0x5a, 0x45, 0x10, 0x04,
	0x22, 0x8c, 0x01, 0x0a, 0x17, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x52, 0x65, 0x64, 0x75, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x14, 0x0a, 0x10,
	0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x5f, 0x4d, 0x49, 0x4e, 0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45,
	0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x5f, 0x4d, 0x41, 0x58,
	0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x53, 0x45, 0x4c, 0x45,
	0x43, 0x54, 0x5f, 0x4c, 0x4f, 0x57, 0x45, 0x52, 0x5f, 0x48, 0x41, 0x4c, 0x46, 0x10, 0x02, 0x12,
	0x15, 0x0a, 0x11, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x5f, 0x55, 0x50, 0x50, 0x45, 0x52, 0x5f,
	0x48, 0x41, 0x4c, 0x46, 0x10, 0x03, 0x12, 0x17, 0x0a, 0x13, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54,
	0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x4e, 0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x10, 0x04, 0x22,
	0x47, 0x0a, 0x19, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62,
	0x6c, 0x65, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04,
	0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73,
	0x12, 0x16, 0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x03,
	0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x22, 0xd8, 0x03, 0x0a, 0x0c, 0x43, 0x70, 0x4d,
	0x6f, 0x64, 0x65, 0x6c, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x4b, 0x0a,
	0x09, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x67,
	0x65, 0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52,
	0x09, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x4a, 0x0a, 0x0b, 0x63, 0x6f,
	0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x28, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x0b, 0x63, 0x6f, 0x6e, 0x73, 0x74,
	0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x47, 0x0a, 0x09, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
	0x69, 0x76, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x73, 0x61, 0x74, 0x2e, 0x43, 0x70, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x52, 0x09, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12,
	0x57, 0x0a, 0x0f, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65,
	0x67, 0x79, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x44, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74,
	0x65, 0x67, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x0e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x57, 0x0a, 0x0d, 0x73, 0x6f, 0x6c, 0x75,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x68, 0x69, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x32, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61,
	0x6c, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x6d,
	0x65, 0x6e, 0x74, 0x52, 0x0c, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x69, 0x6e,
	0x74, 0x12, 0x20, 0x0a, 0x0b, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x18, 0x07, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0b, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x22, 0xb8, 0x07, 0x0a, 0x10, 0x43, 0x70, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3f, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x43, 0x70, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x6f, 0x6c,
	0x75, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x08, 0x73, 0x6f, 0x6c,
	0x75, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x27, 0x0a, 0x0f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69,
	0x76, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0e,
	0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x30,
	0x0a, 0x14, 0x62, 0x65, 0x73, 0x74, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
	0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x12, 0x62, 0x65,
	0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x42, 0x6f, 0x75, 0x6e, 0x64,
	0x12, 0x32, 0x0a, 0x15, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6c, 0x6f, 0x77,
	0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x73, 0x18, 0x12, 0x20, 0x03, 0x28, 0x03, 0x52,
	0x13, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x6f, 0x77, 0x65, 0x72, 0x42, 0x6f,
	0x75, 0x6e, 0x64, 0x73, 0x12, 0x32, 0x0a, 0x15, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x73, 0x18, 0x13, 0x20,
	0x03, 0x28, 0x03, 0x52, 0x13, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x70, 0x70,
	0x65, 0x72, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x73, 0x12, 0x5e, 0x0a, 0x13, 0x74, 0x69, 0x67, 0x68,
	0x74, 0x65, 0x6e, 0x65, 0x64, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18,
	0x15, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e,
	0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x52, 0x12, 0x74, 0x69, 0x67, 0x68, 0x74, 0x65, 0x6e, 0x65, 0x64, 0x56,
	0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x57, 0x0a, 0x28, 0x73, 0x75, 0x66, 0x66,
	0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x66, 0x6f, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x65, 0x61, 0x73, 0x69, 0x62, 0x69,
	0x6c, 0x69, 0x74, 0x79, 0x18, 0x17, 0x20, 0x03, 0x28, 0x05, 0x52, 0x25, 0x73, 0x75, 0x66, 0x66,
	0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x73, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x46, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x65, 0x61, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74,
	0x79, 0x12, 0x37, 0x0a, 0x18, 0x61, 0x6c, 0x6c, 0x5f, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x77, 0x65, 0x72, 0x65, 0x5f, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x15, 0x61, 0x6c, 0x6c, 0x53, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x57, 0x65, 0x72, 0x65, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75,
	0x6d, 0x5f, 0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x0b, 0x6e, 0x75, 0x6d, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x73, 0x12, 0x23, 0x0a,
	0x0d, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x6c, 0x69, 0x63, 0x74, 0x73, 0x18, 0x0b,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x6e, 0x75, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x6c, 0x69, 0x63,
	0x74, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68,
	0x65, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x6e, 0x75, 0x6d, 0x42, 0x72, 0x61,
	0x6e, 0x63, 0x68, 0x65, 0x73, 0x12, 0x36, 0x0a, 0x17, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x69, 0x6e,
	0x61, 0x72, 0x79, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x18, 0x0d, 0x20, 0x01, 0x28, 0x03, 0x52, 0x15, 0x6e, 0x75, 0x6d, 0x42, 0x69, 0x6e, 0x61, 0x72,
	0x79, 0x50, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x38, 0x0a,
	0x18, 0x6e, 0x75, 0x6d, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x5f, 0x70, 0x72, 0x6f,
	0x70, 0x61, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x16, 0x6e, 0x75, 0x6d, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x70, 0x61,
	0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x77, 0x61, 0x6c, 0x6c, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x77, 0x61, 0x6c, 0x6c,
	0x54, 0x69, 0x6d, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d,
	0x65, 0x18, 0x10, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x54, 0x69, 0x6d,
	0x65, 0x12, 0x2d, 0x0a, 0x12, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x69, 0x73, 0x74,
	0x69, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x11, 0x20, 0x01, 0x28, 0x01, 0x52, 0x11, 0x64,
	0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x69, 0x73, 0x74, 0x69, 0x63, 0x54, 0x69, 0x6d, 0x65,
	0x12, 0x27, 0x0a, 0x0f, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x67,
	0x72, 0x61, 0x6c, 0x18, 0x16, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0e, 0x70, 0x72, 0x69, 0x6d, 0x61,
	0x6c, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x61, 0x6c, 0x12, 0x23, 0x0a, 0x0d, 0x73, 0x6f, 0x6c,
	0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x14, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0c, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x2a, 0x5b,
	0x0a, 0x0e, 0x43, 0x70, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x11, 0x0a,
	0x0d, 0x4d, 0x4f, 0x44, 0x45, 0x4c, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x01,
	0x12, 0x0c, 0x0a, 0x08, 0x46, 0x45, 0x41, 0x53, 0x49, 0x42, 0x4c, 0x45, 0x10, 0x02, 0x12, 0x0e,
	0x0a, 0x0a, 0x49, 0x4e, 0x46, 0x45, 0x41, 0x53, 0x49, 0x42, 0x4c, 0x45, 0x10, 0x03, 0x12, 0x0b,
	0x0a, 0x07, 0x4f, 0x50, 0x54, 0x49, 0x4d, 0x41, 0x4c, 0x10, 0x04, 0x42, 0x2e, 0x0a, 0x04, 0x6a,
	0x75, 0x6e, 0x6b, 0x42, 0x0f, 0x43, 0x70, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x50, 0x01, 0xaa, 0x02, 0x12, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x4f, 0x72, 0x54, 0x6f, 0x6f, 0x6c, 0x73, 0x2e, 0x53, 0x61, 0x74, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
}

var (
	file_cp_model_proto_rawDescOnce sync.Once
	file_cp_model_proto_rawDescData = file_cp_model_proto_rawDesc
)

func file_cp_model_proto_rawDescGZIP() []byte {
	file_cp_model_proto_rawDescOnce.Do(func() {
		file_cp_model_proto_rawDescData = protoimpl.X.CompressGZIP(file_cp_model_proto_rawDescData)
	})
	return file_cp_model_proto_rawDescData
}

var file_cp_model_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_cp_model_proto_msgTypes = make([]protoimpl.MessageInfo, 26)
var file_cp_model_proto_goTypes = []interface{}{
	(CpSolverStatus)(0), // 0: operations_research.sat.CpSolverStatus
	(DecisionStrategyProto_VariableSelectionStrategy)(0), // 1: operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy
	(DecisionStrategyProto_DomainReductionStrategy)(0),   // 2: operations_research.sat.DecisionStrategyProto.DomainReductionStrategy
	(*IntegerVariableProto)(nil),                         // 3: operations_research.sat.IntegerVariableProto
	(*BoolArgumentProto)(nil),                            // 4: operations_research.sat.BoolArgumentProto
	(*IntegerArgumentProto)(nil),                         // 5: operations_research.sat.IntegerArgumentProto
	(*LinearExpressionProto)(nil),                        // 6: operations_research.sat.LinearExpressionProto
	(*LinearArgumentProto)(nil),                          // 7: operations_research.sat.LinearArgumentProto
	(*AllDifferentConstraintProto)(nil),                  // 8: operations_research.sat.AllDifferentConstraintProto
	(*LinearConstraintProto)(nil),                        // 9: operations_research.sat.LinearConstraintProto
	(*ElementConstraintProto)(nil),                       // 10: operations_research.sat.ElementConstraintProto
	(*IntervalConstraintProto)(nil),                      // 11: operations_research.sat.IntervalConstraintProto
	(*NoOverlapConstraintProto)(nil),                     // 12: operations_research.sat.NoOverlapConstraintProto
	(*NoOverlap2DConstraintProto)(nil),                   // 13: operations_research.sat.NoOverlap2DConstraintProto
	(*CumulativeConstraintProto)(nil),                    // 14: operations_research.sat.CumulativeConstraintProto
	(*ReservoirConstraintProto)(nil),                     // 15: operations_research.sat.ReservoirConstraintProto
	(*CircuitConstraintProto)(nil),                       // 16: operations_research.sat.CircuitConstraintProto
	(*RoutesConstraintProto)(nil),                        // 17: operations_research.sat.RoutesConstraintProto
	(*CircuitCoveringConstraintProto)(nil),               // 18: operations_research.sat.CircuitCoveringConstraintProto
	(*TableConstraintProto)(nil),                         // 19: operations_research.sat.TableConstraintProto
	(*InverseConstraintProto)(nil),                       // 20: operations_research.sat.InverseConstraintProto
	(*AutomatonConstraintProto)(nil),                     // 21: operations_research.sat.AutomatonConstraintProto
	(*ConstraintProto)(nil),                              // 22: operations_research.sat.ConstraintProto
	(*CpObjectiveProto)(nil),                             // 23: operations_research.sat.CpObjectiveProto
	(*DecisionStrategyProto)(nil),                        // 24: operations_research.sat.DecisionStrategyProto
	(*PartialVariableAssignment)(nil),                    // 25: operations_research.sat.PartialVariableAssignment
	(*CpModelProto)(nil),                                 // 26: operations_research.sat.CpModelProto
	(*CpSolverResponse)(nil),                             // 27: operations_research.sat.CpSolverResponse
	(*DecisionStrategyProto_AffineTransformation)(nil),   // 28: operations_research.sat.DecisionStrategyProto.AffineTransformation
}
var file_cp_model_proto_depIdxs = []int32{
	6,  // 0: operations_research.sat.LinearArgumentProto.target:type_name -> operations_research.sat.LinearExpressionProto
	6,  // 1: operations_research.sat.LinearArgumentProto.exprs:type_name -> operations_research.sat.LinearExpressionProto
	4,  // 2: operations_research.sat.ConstraintProto.bool_or:type_name -> operations_research.sat.BoolArgumentProto
	4,  // 3: operations_research.sat.ConstraintProto.bool_and:type_name -> operations_research.sat.BoolArgumentProto
	4,  // 4: operations_research.sat.ConstraintProto.at_most_one:type_name -> operations_research.sat.BoolArgumentProto
	4,  // 5: operations_research.sat.ConstraintProto.bool_xor:type_name -> operations_research.sat.BoolArgumentProto
	5,  // 6: operations_research.sat.ConstraintProto.int_div:type_name -> operations_research.sat.IntegerArgumentProto
	5,  // 7: operations_research.sat.ConstraintProto.int_mod:type_name -> operations_research.sat.IntegerArgumentProto
	5,  // 8: operations_research.sat.ConstraintProto.int_max:type_name -> operations_research.sat.IntegerArgumentProto
	7,  // 9: operations_research.sat.ConstraintProto.lin_max:type_name -> operations_research.sat.LinearArgumentProto
	5,  // 10: operations_research.sat.ConstraintProto.int_min:type_name -> operations_research.sat.IntegerArgumentProto
	7,  // 11: operations_research.sat.ConstraintProto.lin_min:type_name -> operations_research.sat.LinearArgumentProto
	5,  // 12: operations_research.sat.ConstraintProto.int_prod:type_name -> operations_research.sat.IntegerArgumentProto
	9,  // 13: operations_research.sat.ConstraintProto.linear:type_name -> operations_research.sat.LinearConstraintProto
	8,  // 14: operations_research.sat.ConstraintProto.all_diff:type_name -> operations_research.sat.AllDifferentConstraintProto
	10, // 15: operations_research.sat.ConstraintProto.element:type_name -> operations_research.sat.ElementConstraintProto
	16, // 16: operations_research.sat.ConstraintProto.circuit:type_name -> operations_research.sat.CircuitConstraintProto
	17, // 17: operations_research.sat.ConstraintProto.routes:type_name -> operations_research.sat.RoutesConstraintProto
	18, // 18: operations_research.sat.ConstraintProto.circuit_covering:type_name -> operations_research.sat.CircuitCoveringConstraintProto
	19, // 19: operations_research.sat.ConstraintProto.table:type_name -> operations_research.sat.TableConstraintProto
	21, // 20: operations_research.sat.ConstraintProto.automaton:type_name -> operations_research.sat.AutomatonConstraintProto
	20, // 21: operations_research.sat.ConstraintProto.inverse:type_name -> operations_research.sat.InverseConstraintProto
	15, // 22: operations_research.sat.ConstraintProto.reservoir:type_name -> operations_research.sat.ReservoirConstraintProto
	11, // 23: operations_research.sat.ConstraintProto.interval:type_name -> operations_research.sat.IntervalConstraintProto
	12, // 24: operations_research.sat.ConstraintProto.no_overlap:type_name -> operations_research.sat.NoOverlapConstraintProto
	13, // 25: operations_research.sat.ConstraintProto.no_overlap_2d:type_name -> operations_research.sat.NoOverlap2DConstraintProto
	14, // 26: operations_research.sat.ConstraintProto.cumulative:type_name -> operations_research.sat.CumulativeConstraintProto
	1,  // 27: operations_research.sat.DecisionStrategyProto.variable_selection_strategy:type_name -> operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy
	2,  // 28: operations_research.sat.DecisionStrategyProto.domain_reduction_strategy:type_name -> operations_research.sat.DecisionStrategyProto.DomainReductionStrategy
	28, // 29: operations_research.sat.DecisionStrategyProto.transformations:type_name -> operations_research.sat.DecisionStrategyProto.AffineTransformation
	3,  // 30: operations_research.sat.CpModelProto.variables:type_name -> operations_research.sat.IntegerVariableProto
	22, // 31: operations_research.sat.CpModelProto.constraints:type_name -> operations_research.sat.ConstraintProto
	23, // 32: operations_research.sat.CpModelProto.objective:type_name -> operations_research.sat.CpObjectiveProto
	24, // 33: operations_research.sat.CpModelProto.search_strategy:type_name -> operations_research.sat.DecisionStrategyProto
	25, // 34: operations_research.sat.CpModelProto.solution_hint:type_name -> operations_research.sat.PartialVariableAssignment
	0,  // 35: operations_research.sat.CpSolverResponse.status:type_name -> operations_research.sat.CpSolverStatus
	3,  // 36: operations_research.sat.CpSolverResponse.tightened_variables:type_name -> operations_research.sat.IntegerVariableProto
	37, // [37:37] is the sub-list for method output_type
	37, // [37:37] is the sub-list for method input_type
	37, // [37:37] is the sub-list for extension type_name
	37, // [37:37] is the sub-list for extension extendee
	0,  // [0:37] is the sub-list for field type_name
}

func init() { file_cp_model_proto_init() }
func file_cp_model_proto_init() {
	if File_cp_model_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_cp_model_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IntegerVariableProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BoolArgumentProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IntegerArgumentProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinearExpressionProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinearArgumentProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AllDifferentConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinearConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ElementConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IntervalConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NoOverlapConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NoOverlap2DConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CumulativeConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReservoirConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CircuitConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RoutesConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CircuitCoveringConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TableConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InverseConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutomatonConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CpObjectiveProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DecisionStrategyProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PartialVariableAssignment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CpModelProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CpSolverResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DecisionStrategyProto_AffineTransformation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_cp_model_proto_msgTypes[19].OneofWrappers = []interface{}{
		(*ConstraintProto_BoolOr)(nil),
		(*ConstraintProto_BoolAnd)(nil),
		(*ConstraintProto_AtMostOne)(nil),
		(*ConstraintProto_BoolXor)(nil),
		(*ConstraintProto_IntDiv)(nil),
		(*ConstraintProto_IntMod)(nil),
		(*ConstraintProto_IntMax)(nil),
		(*ConstraintProto_LinMax)(nil),
		(*ConstraintProto_IntMin)(nil),
		(*ConstraintProto_LinMin)(nil),
		(*ConstraintProto_IntProd)(nil),
		(*ConstraintProto_Linear)(nil),
		(*ConstraintProto_AllDiff)(nil),
		(*ConstraintProto_Element)(nil),
		(*ConstraintProto_Circuit)(nil),
		(*ConstraintProto_Routes)(nil),
		(*ConstraintProto_CircuitCovering)(nil),
		(*ConstraintProto_Table)(nil),
		(*ConstraintProto_Automaton)(nil),
		(*ConstraintProto_Inverse)(nil),
		(*ConstraintProto_Reservoir)(nil),
		(*ConstraintProto_Interval)(nil),
		(*ConstraintProto_NoOverlap)(nil),
		(*ConstraintProto_NoOverlap_2D)(nil),
		(*ConstraintProto_Cumulative)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_cp_model_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   26,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cp_model_proto_goTypes,
		DependencyIndexes: file_cp_model_proto_depIdxs,
		EnumInfos:         file_cp_model_proto_enumTypes,
		MessageInfos:      file_cp_model_proto_msgTypes,
	}.Build()
	File_cp_model_proto = out.File
	file_cp_model_proto_rawDesc = nil
	file_cp_model_proto_goTypes = nil
	file_cp_model_proto_depIdxs = nil
}
